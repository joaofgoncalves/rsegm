<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Tiled segmentation workflow • rsegm</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Tiled segmentation workflow">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rsegm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/tiled-segmentation-workflow.html">Tiled segmentation workflow</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/joaofgoncalves/rsegm/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Tiled segmentation workflow</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/joaofgoncalves/rsegm/blob/HEAD/vignettes/tiled-segmentation-workflow.Rmd" class="external-link"><code>vignettes/tiled-segmentation-workflow.Rmd</code></a></small>
      <div class="d-none name"><code>tiled-segmentation-workflow.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p>This vignette describes the <strong>tiled segmentation
framework</strong> implemented in the <code>rsegm</code> package. The
framework is designed for large remote-sensing rasters that cannot be
segmented reliably or efficiently in memory as a single scene.</p>
<p>The core idea is to:</p>
<ol style="list-style-type: decimal">
<li>Split the image into overlapping tiles on disk<br>
</li>
<li>Segment each tile independently<br>
</li>
<li>Detect and reconcile inconsistencies along tile seams<br>
</li>
<li>Merge spectrally similar segments across seams<br>
</li>
<li>Produce a globally consistent segmentation with compact IDs</li>
</ol>
<p>The workflow is orchestrated by <a href="../reference/segmenter_tile_engine.html"><code>segmenter_tile_engine()</code></a>.</p>
<hr>
</div>
<div class="section level2">
<h2 id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h2>
<p>Classical OBIA segmentation algorithms (region growing, FH,
mean-shift, multiresolution) are sensitive to boundary conditions. When
applied tile-wise, objects crossing tile borders are often split
inconsistently.</p>
<p>This framework addresses that problem by:</p>
<ul>
<li>
<strong>using overlap (buffers)</strong> during segmentation,</li>
<li>
<strong>restricting merge decisions to seam zones</strong>, and</li>
<li>
<strong>merging only spectrally similar adjacent
segments</strong>.</li>
</ul>
<p>All steps are implemented in a <strong>streaming-safe</strong>,
disk-backed manner using <code>terra</code>, making the approach
suitable for very large rasters.</p>
<hr>
</div>
<div class="section level2">
<h2 id="step-1-deterministic-tiling-with-overlap">Step 1: Deterministic tiling with overlap<a class="anchor" aria-label="anchor" href="#step-1-deterministic-tiling-with-overlap"></a>
</h2>
<p>The input raster is split into tiles of fixed size
(<code>tile_size x tile_size</code>) with an additional overlap
(<code>buffer</code>) on all sides.</p>
<p>Each tile is written to disk and accompanied by metadata
describing:</p>
<ul>
<li>the <em>inner</em> (non-overlapping) window, and</li>
<li>the <em>buffered</em> window actually written to disk.</li>
</ul>
<p>This metadata is later reused to identify seam zones and adjacency
relations deterministically.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/make_tiles_disk.html">make_tiles_disk()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-2-segment-each-tile-and-ensure-global-id-uniqueness">Step 2: Segment each tile and ensure global ID uniqueness<a class="anchor" aria-label="anchor" href="#step-2-segment-each-tile-and-ensure-global-id-uniqueness"></a>
</h2>
<p>Each tile is segmented independently by a user-supplied segmentation
function (e.g., FH, region growing, mean-shift).</p>
<p>To avoid label collisions between tiles, the engine applies a
<strong>running global offset</strong> to segment IDs:</p>
<ul>
<li>only labels <code>&gt; 0</code> are offset,</li>
<li>
<code>NA</code> values are preserved,</li>
<li>offsets are accumulated tile by tile.</li>
</ul>
<p>As a result, every segment ID is globally unique <em>before</em> any
seam merging is attempted.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/segment_tiles.html">segment_tiles()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-3-seam-masks-and-adjacency-detection">Step 3: Seam masks and adjacency detection<a class="anchor" aria-label="anchor" href="#step-3-seam-masks-and-adjacency-detection"></a>
</h2>
<p>Only segments touching across tile borders should be considered for
merging. To identify these candidates, the framework:</p>
<ol style="list-style-type: decimal">
<li>Builds a <strong>seam mask</strong> around the inner tile
boundary</li>
<li>Extracts segment adjacency pairs where at least one pixel lies in
the seam</li>
</ol>
<p>Adjacency can be computed using 4- or 8-neighborhood connectivity (8
by default).</p>
<p>Relevant functions:</p>
<ul>
<li><code>make_tile_seam_mask()</code></li>
<li><code>extract_seam_pairs()</code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-4-compute-per-segment-means-from-tiles">Step 4: Compute per-segment means from tiles<a class="anchor" aria-label="anchor" href="#step-4-compute-per-segment-means-from-tiles"></a>
</h2>
<p>For each candidate segment ID involved in a seam adjacency, the
framework computes mean feature vectors (typically spectral band
means).</p>
<p>Means are computed by <strong>streaming over segmentation
tiles</strong> and reading the corresponding image values block-wise.
This avoids:</p>
<ul>
<li>loading the full image into memory, and</li>
<li>relying on virtual raster (VRT) reads.</li>
</ul>
<p>If necessary, image subsets are resampled to match the segmentation
grid before streaming.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/segment_means_from_tiles.html">segment_means_from_tiles()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-5-merge-adjacent-segments-by-similarity">Step 5: Merge adjacent segments by similarity<a class="anchor" aria-label="anchor" href="#step-5-merge-adjacent-segments-by-similarity"></a>
</h2>
<p>Adjacent seam segments are merged when their mean feature vectors are
sufficiently similar.</p>
<p>Similarity is evaluated using Euclidean distance, and merges are
applied using a <strong>union-find (disjoint-set)</strong> structure.
This ensures transitive consistency:</p>
<blockquote>
<p>If A merges with B, and B merges with C, then A, B, and C all belong
to the same final segment.</p>
</blockquote>
<p>The result is a <strong>merge map</strong> from original IDs to
representative IDs.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/merge_by_adjacency.html">merge_by_adjacency()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-6-apply-merge-map-with-streaming-io">Step 6: Apply merge map with streaming I/O<a class="anchor" aria-label="anchor" href="#step-6-apply-merge-map-with-streaming-io"></a>
</h2>
<p>The segmented tiles are first mosaicked into a real, file-backed
raster to ensure stable I/O.</p>
<p>The merge map is then applied block-wise:</p>
<ul>
<li>read a block of segment IDs,</li>
<li>replace IDs according to the map,</li>
<li>write the block back to disk.</li>
</ul>
<p>This step is safe for very large rasters.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/apply_merge_map.html">apply_merge_map()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="step-7-global-relabeling">Step 7: Global relabeling<a class="anchor" aria-label="anchor" href="#step-7-global-relabeling"></a>
</h2>
<p>After merging, segment IDs may be sparse or non-consecutive. For
convenience and downstream compatibility, all non-<code>NA</code>
segment IDs are relabeled to a compact <code>1..K</code> sequence in a
deterministic way.</p>
<p>Relevant function:</p>
<ul>
<li><code><a href="../reference/relabel_segments_global.html">relabel_segments_global()</a></code></li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="end-to-end-orchestration">End-to-end orchestration<a class="anchor" aria-label="anchor" href="#end-to-end-orchestration"></a>
</h2>
<p>All steps above are coordinated by:</p>
<ul>
<li><code><a href="../reference/segmenter_tile_engine.html">segmenter_tile_engine()</a></code></li>
</ul>
<p>This function implements the full pipeline with sensible defaults and
provides early exits when no seam merging is required.</p>
<hr>
</div>
<div class="section level2">
<h2 id="typical-usage">Typical usage<a class="anchor" aria-label="anchor" href="#typical-usage"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">seg</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/segmenter_tile_engine.html">segmenter_tile_engine</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="va">img</span>,</span>
<span>  segment_fun <span class="op">=</span> <span class="va">fh_meanshift_segmenter</span>,</span>
<span>  seg_args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>fh_k <span class="op">=</span> <span class="fl">0.5</span>, fh_min_size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>,</span>
<span>  tile_size <span class="op">=</span> <span class="fl">2048</span>,</span>
<span>  buffer <span class="op">=</span> <span class="fl">64</span>,</span>
<span>  seam_thr <span class="op">=</span> <span class="fl">0.8</span>,</span>
<span>  out_file <span class="op">=</span> <span class="st">"segmentation.tif"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<hr>
</div>
<div class="section level2">
<h2 id="notes-and-extensions">Notes and extensions<a class="anchor" aria-label="anchor" href="#notes-and-extensions"></a>
</h2>
<ul>
<li>The merging criterion can be extended to other features (e.g.,
texture, shape, multiscale descriptors).</li>
<li>Union-find merging can be replaced by graph-based clustering if
needed.</li>
<li>Rcpp acceleration can be added to adjacency extraction and merge
evaluation without changing the high-level API.</li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<p>The tiled segmentation framework in <code>rsegm</code> provides a
robust and scalable way to apply classical OBIA segmentation methods to
large rasters while minimizing tile seam artifacts and maintaining
global consistency.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by João Gonçalves.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>

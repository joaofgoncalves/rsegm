[{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Tiled segmentation workflow","text":"vignette describes tiled segmentation framework implemented rsegm package. framework designed large remote-sensing rasters segmented reliably efficiently memory single scene. core idea : Split image overlapping tiles disk Segment tile independently Detect reconcile inconsistencies along tile seams Merge spectrally similar segments across seams Produce globally consistent segmentation compact IDs workflow orchestrated segmenter_tile_engine().","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Tiled segmentation workflow","text":"Classical OBIA segmentation algorithms (region growing, FH, mean-shift, multiresolution) sensitive boundary conditions. applied tile-wise, objects crossing tile borders often split inconsistently. framework addresses problem : using overlap (buffers) segmentation, restricting merge decisions seam zones, merging spectrally similar adjacent segments. steps implemented streaming-safe, disk-backed manner using terra, making approach suitable large rasters.","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-1-deterministic-tiling-with-overlap","dir":"Articles","previous_headings":"","what":"Step 1: Deterministic tiling with overlap","title":"Tiled segmentation workflow","text":"input raster split tiles fixed size (tile_size x tile_size) additional overlap (buffer) sides. tile written disk accompanied metadata describing: inner (non-overlapping) window, buffered window actually written disk. metadata later reused identify seam zones adjacency relations deterministically. Relevant function: make_tiles_disk()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-2-segment-each-tile-and-ensure-global-id-uniqueness","dir":"Articles","previous_headings":"","what":"Step 2: Segment each tile and ensure global ID uniqueness","title":"Tiled segmentation workflow","text":"tile segmented independently user-supplied segmentation function (e.g., FH, region growing, mean-shift). avoid label collisions tiles, engine applies running global offset segment IDs: labels > 0 offset, NA values preserved, offsets accumulated tile tile. result, every segment ID globally unique seam merging attempted. Relevant function: segment_tiles()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-3-seam-masks-and-adjacency-detection","dir":"Articles","previous_headings":"","what":"Step 3: Seam masks and adjacency detection","title":"Tiled segmentation workflow","text":"segments touching across tile borders considered merging. identify candidates, framework: Builds seam mask around inner tile boundary Extracts segment adjacency pairs least one pixel lies seam Adjacency can computed using 4- 8-neighborhood connectivity (8 default). Relevant functions: make_tile_seam_mask() extract_seam_pairs()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-4-compute-per-segment-means-from-tiles","dir":"Articles","previous_headings":"","what":"Step 4: Compute per-segment means from tiles","title":"Tiled segmentation workflow","text":"candidate segment ID involved seam adjacency, framework computes mean feature vectors (typically spectral band means). Means computed streaming segmentation tiles reading corresponding image values block-wise. avoids: loading full image memory, relying virtual raster (VRT) reads. necessary, image subsets resampled match segmentation grid streaming. Relevant function: segment_means_from_tiles()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-5-merge-adjacent-segments-by-similarity","dir":"Articles","previous_headings":"","what":"Step 5: Merge adjacent segments by similarity","title":"Tiled segmentation workflow","text":"Adjacent seam segments merged mean feature vectors sufficiently similar. Similarity evaluated using Euclidean distance, merges applied using union-find (disjoint-set) structure. ensures transitive consistency: merges B, B merges C, , B, C belong final segment. result merge map original IDs representative IDs. Relevant function: merge_by_adjacency()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-6-apply-merge-map-with-streaming-io","dir":"Articles","previous_headings":"","what":"Step 6: Apply merge map with streaming I/O","title":"Tiled segmentation workflow","text":"segmented tiles first mosaicked real, file-backed raster ensure stable /O. merge map applied block-wise: read block segment IDs, replace IDs according map, write block back disk. step safe large rasters. Relevant function: apply_merge_map()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"step-7-global-relabeling","dir":"Articles","previous_headings":"","what":"Step 7: Global relabeling","title":"Tiled segmentation workflow","text":"merging, segment IDs may sparse non-consecutive. convenience downstream compatibility, non-NA segment IDs relabeled compact 1..K sequence deterministic way. Relevant function: relabel_segments_global()","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"end-to-end-orchestration","dir":"Articles","previous_headings":"","what":"End-to-end orchestration","title":"Tiled segmentation workflow","text":"steps coordinated : segmenter_tile_engine() function implements full pipeline sensible defaults provides early exits seam merging required.","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"typical-usage","dir":"Articles","previous_headings":"","what":"Typical usage","title":"Tiled segmentation workflow","text":"","code":"seg <- segmenter_tile_engine(   x = img,   segment_fun = fh_meanshift_segmenter,   seg_args = list(fh_k = 0.5, fh_min_size = 20),   tile_size = 2048,   buffer = 64,   seam_thr = 0.8,   out_file = \"segmentation.tif\" )"},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"notes-and-extensions","dir":"Articles","previous_headings":"","what":"Notes and extensions","title":"Tiled segmentation workflow","text":"merging criterion can extended features (e.g., texture, shape, multiscale descriptors). Union-find merging can replaced graph-based clustering needed. Rcpp acceleration can added adjacency extraction merge evaluation without changing high-level API.","code":""},{"path":"http://joaogoncalves.cc/rsegm/articles/tiled-segmentation-workflow.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Tiled segmentation workflow","text":"tiled segmentation framework rsegm provides robust scalable way apply classical OBIA segmentation methods large rasters minimizing tile seam artifacts maintaining global consistency.","code":""},{"path":"http://joaogoncalves.cc/rsegm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"João Gonçalves. Author, maintainer.","code":""},{"path":"http://joaogoncalves.cc/rsegm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gonçalves J (2025). rsegm: Geospatial Image Segmentation Using Classical OBIA Methods. https://github.com/joaofgoncalves/rsegm, http://joaogoncalves.cc/rsegm/.","code":"@Manual{,   title = {rsegm: Geospatial Image Segmentation Using Classical OBIA Methods},   author = {João Gonçalves},   year = {2025},   note = {https://github.com/joaofgoncalves/rsegm, http://joaogoncalves.cc/rsegm/}, }"},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"geospatial-image-segmentation-in-r","dir":"","previous_headings":"","what":"Geospatial Image Segmentation Using Classical OBIA Methods","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"rsegm package provides scalable, high-performance tools geospatial image segmentation built top terra, Rcpp, modern block-wise / tiled processing strategies. designed object-based image analysis (OBIA) workflows large raster datasets, including satellite aerial imagery. core focus producing spatially coherent, integer-labeled segment rasters integrate cleanly downstream raster vector analysis R.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"main-features","dir":"","previous_headings":"","what":"Main features","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Fast Felzenszwalb-Huttenlocher (FH) graph-based segmentation Hybrid FH + region-level Mean Shift segmentation higher-quality objects Mean-shift Baatz-Schäpe multi-resolution Fast Baatz-Schäpe multi-resolution SEEDS Robust tiled processing rasters fit comfortably memory Seam-aware merging avoid boundary artifacts Computationally intensive steps implemented Rcpp speed scalability Uses SpatRaster throughout Produces standard GeoTIFF outputs integer segment IDs","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"segmentation-methods","dir":"","previous_headings":"","what":"Segmentation methods","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"package currently includes: FH graph-based segmentation fast, noise-robust method often used generate superpixels initial regions, suitable large multi-band rasters. FH + mean shift hybrid segmentation two-stage approach combining FH -segmentation region-level Mean Shift refinement merge spectrally similar regions efficiently, producing object-like segments well suited OBIA workflows. Mean Shift segmentation pixel-domain mean-shift filtering clustering method produces smooth, spectrally homogeneous segments higher computational cost, best suited small medium-sized images. Baatz–Schäpe multiresolution segmentation classical OBIA algorithm iteratively merges adjacent regions based spectral heterogeneity shape criteria, producing high-quality multi-scale objects expense higher runtime. Fast Baatz–Schäpe multiresolution segmentation optimized variant Baatz–Schäpe algorithm using efficient region bookkeeping priority-queue merging achieve substantially faster performance small medium rasters. SEEDS superpixel segmentation hierarchical, histogram-based superpixel method starts regular grid refines boundaries via local block moves, designed speed, locality, tile-friendly large-raster processing. methods return single-layer raster cell contains integer segment identifier. Example","code":"library(terra) library(rsegm)  r <- rast(sample_raster_path())   print(r)  # Segment image using FH method # seg <- fh_segmenter(   r,   k = 0.5,   min_size = 40,   eight = TRUE,   scale_bands = TRUE,   smooth = 3 )  seg_pol   <- as.polygons(seg, dissolve = TRUE) seg_lines <- as.lines(seg_pol)  rgb <- r[[1:3]] rgb <- stretch(rgb)  plotRGB(rgb, r=1, g=2, b=3, stretch=\"lin\") plot(seg_lines, add=TRUE, col=\"yellow\", lwd=0.8)"},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"tiled-processing","dir":"","previous_headings":"","what":"Tiled processing","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"large scenes, segmentation can executed tiled workflow : Splits input raster buffered tiles disk Segments tile independently Ensures globally unique segment IDs across tiles Detects merges adjacent segments across tile seams Produces single, seamless output raster approach allows segmentation large rasters maintaining correctness reproducibility.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"typical-workflow-with-tiling","dir":"","previous_headings":"","what":"Typical workflow with tiling","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"","code":"library(terra) library(rsegm)  r <- rast(\"very_large_multispectral_image.tif\")  seg <- fh_segmenter_tile(   r,   tile_size = 2048,   buffer = 64,   k = 0.7,   min_size = 60,   smooth = 3,   out_file = \"segmented.tif\" )"},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"tiling-and-segmentation-parameters","dir":"","previous_headings":"","what":"Tiling and segmentation parameters","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"section explains main parameters controlling tiled segmentation provides practical guidance selecting appropriate values.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"tile_size","dir":"","previous_headings":"Tiling and segmentation parameters","what":"tile_size","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Defines spatial size (pixels) processing tile. tile segmented independently later merged. Larger values reduce number seams require memory Smaller values lower memory usage increase number tile boundaries parameter controls fundamental processing unit tiled workflow.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"buffer","dir":"","previous_headings":"Tiling and segmentation parameters","what":"buffer","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Defines overlap (pixels) added around tile. Prevents artificial boundaries tile edges Ensures sufficient spatial context segments near tile borders Used segmentation seam reconciliation buffer generally larger expected object size larger segmentation neighborhood.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"k","dir":"","previous_headings":"Tiling and segmentation parameters","what":"k","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Segmentation scale parameter graph-based segmentation. Lower values produce many small segments (-segmentation) Higher values produce fewer, larger segments k independent tiling, strongly influences visible tile seams become set low.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"practical-guidelines","dir":"","previous_headings":"Tiling and segmentation parameters","what":"Practical guidelines","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Increase tile_size first tiling patterns visible Increase buffer segment boundaries align tile edges Adjust k last control object size seams handled Ensure:buffer >= expected object radiustile_size >> buffer result GeoTIFF globally consistent segment IDs, suitable visualization, statistics, conversion vector objects.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"design-principles","dir":"","previous_headings":"","what":"Design principles","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Favor explicitness magic: segment IDs, tiling, merging steps transparent. robust raster size storage mode (-memory vs file-backed). Keep outputs simple interoperable: integer labels, one layer, hidden state.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"terra raster /O spatial operations Rcpp performance-critical algorithms Base R (stats, utils)","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"benchmark-times","dir":"","previous_headings":"","what":"Benchmark times","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"Run times Windows 11, Intel Core 7 (8thGen), 16Gb machine: Empirical runtime analysis indicates near-linear scaling OBIA algorithms implemented rsegm, algorithm-specific deviations driven internal neighborhood search, hierarchical merging, iterative refinement steps rather pixel traversal alone. Log–log regression median runtime image size (MPix) reveals strong power-law relationship across methods (R² ~ 0.88-1.00). estimated scaling exponents span sublinear (~0.5-0.7) slightly superlinear (~1.07), indicating methods efficient tested range, differ meaningfully per-pixel work grows scene size. brief can summarized : Best scalability: SEEDS, FH, FH mean-shift Best trade-: Baatz multi-res fast Highest quality / highest cost: Baatz multi-resolution, Mean-shift empirical analysis supports algorithm selection based scene size workflow constraints, rather assuming uniform “linear” behavior across OBIA methods.","code":""},{"path":"http://joaogoncalves.cc/rsegm/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Geospatial Image Segmentation Using Classical OBIA Methods","text":"See DESCRIPTION file licensing package metadata.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/apply_merge_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","title":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","text":"Applies mapping original segment IDs merged (representative) IDs writes updated segmentation disk using block-wise streaming. intended large, file-backed rasters avoids reading full segmentation memory.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/apply_merge_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","text":"","code":"apply_merge_map(seg, map, out_file, block_nrows = 1024L)"},{"path":"http://joaogoncalves.cc/rsegm/reference/apply_merge_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","text":"seg `SpatRaster` containing integer segment labels. map Named integer vector defining relabeling/merge map. Names original segment IDs (character strings) values target IDs (typically representatives produced `merge_by_adjacency()`). out_file Character. Output file path (GeoTIFF recommended). block_nrows Integer. Number rows per streaming block reading writing.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/apply_merge_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","text":"file-backed `SpatRaster` pointing `out_file`.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/apply_merge_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a segment merge map to a segmentation raster (streaming-safe) — apply_merge_map","text":"function streams `seg` row blocks, replaces values match `names(map)`, writes result `out_file`. Values present map left unchanged. `NA` values preserved. **terra /O note.** terra, `writeStart()` returns list; function intentionally ignores return value continues writing `SpatRaster` object used `writeStart()`. ensures compatibility terra versions writing returned list incorrect. output written integer datatype (`INT4S`) default GDAL creation options used package.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"Performs **fast** multiresolution image segmentation inspired Baatz-Schape OBIA algorithm.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"","code":"baatz_fast_segmenter(   x,   scale_param = 50,   color_weight = 0.9,   compactness = 0.5,   band_weights = NULL,   smooth = 0L,   output_file = NULL,   verbose = FALSE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"x SpatRaster character string giving path raster readable terra. scale_param Numeric scalar controlling segmentation scale. Larger values tend produce larger segments. Internally, C++ routine uses threshold proportional scale_param^2 merge acceptance. color_weight Numeric \\([0,1]\\) controlling relative importance spectral (color) heterogeneity versus shape. Higher values emphasize spectral similarity. compactness Numeric \\([0,1]\\) controlling trade-compactness smoothness shape criterion. band_weights Optional numeric vector length equal number bands x. Provides per-band weights spectral component. NULL, bands weighted equally. smooth Integer \\(\\ge 0\\). Optional mean filter window size (pixels) applied raster prior mean-shift. 0 (default), pre-smoothing applied. > 0, smooth x smooth mean filter applied via terra::focal(). output_file Optional character string. provided, resulting segmentation raster written file via terra::writeRaster(). verbose Logical. TRUE, prints progress messages R wrapper enables verbose output underlying C++ routine. FALSE (default), runs quietly.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"single-layer SpatRaster integer segment labels   layer named \"segments\".","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"Compared baatz_segmenter, function calls streamlined C++ implementation designed substantially faster small medium rasters using efficient region bookkeeping, priority-queue merge candidates, disjoint-set union (DSU) structure finalize labels. input raster converted dense matrix \\(n_{pixels} \\times n_{bands}\\). missing values replaced corresponding band mean segmentation. C++ routine initializes one region per pixel builds 4-neighbour adjacencies, tracking shared boundary length neighbouring regions. Candidate merges scored *fusion factor* combining: spectral term based increase within-region variance         (computed per-region band sums sums squares), shape term combines compactness smoothness based         region perimeter bounding-box perimeter, accounting         shared boundary length two regions. Merges greedily applied increasing fusion-factor order candidate remains scale threshold. Final labels remapped consecutive integers starting 1. Label values arbitrary treated categorical.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"Baatz, M. & Schape, . (2000). Multiresolution Segmentation: Optimization Approach High Quality Multi-Scale Image Segmentation. : Strobl et al. (eds), Angewandte Geographische Informationsverarbeitung XII.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_fast_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast Baatz-Schape multiresolution segmentation — baatz_fast_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) r <- terra::rast(sample_raster_path())  seg <- baatz_fast_segmenter(   r,   scale_param = 50,   color_weight = 0.9,   compactness = 0.5,   verbose = TRUE ) plot(seg) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Baatz-Schape multiresolution segmentation — baatz_segmenter","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"Performs multiresolution image segmentation following Baatz-Schape algorithm, commonly used object-based image analysis (OBIA). algorithm iteratively merges adjacent pixels regions based spectral heterogeneity shape constraints.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"","code":"baatz_segmenter(   x,   scale_param = 50,   color_weight = 0.9,   compactness = 0.5,   band_weights = NULL,   smooth = 0L,   output_file = NULL,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"x `SpatRaster` object character string giving path raster file readable terra. scale_param Numeric scalar controlling segmentation scale. Larger values result larger segments. Roughly corresponds maximum allowed increase heterogeneity merging regions. color_weight Numeric value \\([0,1]\\) giving relative importance spectral (color) heterogeneity versus shape. Higher values emphasize spectral similarity. compactness Numeric value \\([0,1]\\) controlling trade-compactness smoothness shape criterion. band_weights Optional numeric vector length equal number bands `x`, giving per-band weights spectral heterogeneity term. `NULL`, bands weighted equally. smooth Integer \\(\\ge 0\\). Optional mean filter window size (pixels) applied raster prior mean-shift. 0 (default), pre-smoothing applied. > 0, smooth x smooth mean filter applied via terra::focal(). output_file Optional character string. provided, resulting segmentation raster written file using writeRaster. verbose progress messages? (default: TRUE)","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"single-layer `SpatRaster` integer segment labels.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"function high-level R wrapper around lower-level Baatz-Schape segmentation implementation, handling raster /O, preprocessing, conversion output back `SpatRaster`. Input rasters internally converted matrix \\(n_{pixels} \\times n_{bands}\\). Pixels containing `NA` values band replaced corresponding band mean prior segmentation. segmentation labels returned integer region identifiers. Label values arbitrary treated categorical. implementation intended small medium-sized rasters. large images, consider tiling strategies --core processing.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"Baatz, M. & Schape, . (2000). Multiresolution Segmentation: Optimization Approach High Quality Multi-Scale Image Segmentation. : Strobl et al. (eds), Angewandte Geographische Informationsverarbeitung XII.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/baatz_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Baatz-Schape multiresolution segmentation — baatz_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) r <- rast(system.file(\"extdata\", \"sample_raster.tif\", package = \"rsegm\"))  seg <- baatz_segmenter(   r,   scale_param = 50,   color_weight = 0.9,   compactness = 0.5 )  plot(seg) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"Performs high-quality, scalable image segmentation combining fast graph-based region merging step (Felzenszwalb-Huttenlocher, FH) region-level Mean-Shift refinement. hybrid approach achieves good segmentation quality remaining computationally efficient large, multi-band raster images.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"","code":"fh_meanshift_segmenter(   x,   scale_bands = TRUE,   smooth = 3,   fh_k = 0.5,   fh_min_size = 20,   eight = TRUE,   ms_dim = 0,   ms_ranger = 0.15,   ms_hs = 12,   ms_max_iter = 10,   ms_eps = 0.001,   mode_merge = 0.6,   final_min_size = 80,   output_file = NULL,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"x SpatRaster. Input image segment. May multi-band (e.g., RGB, VNIR, VNIR+SWIR). scale_bands logical, default TRUE. TRUE, band centered scaled unit variance prior segmentation. Strongly recommended multi-sensor multi-band data. smooth integer, default 3. Size square mean-filter kernel applied segmentation. Set 0 disable smoothing. Values 3 5 often reduce speckle improve boundary stability. fh_k numeric, default 0.5. Scale parameter FH region-merging step. Larger values produce fewer, larger initial regions; smaller values preserve fine detail. fh_min_size integer, default 20. Minimum allowed size (pixels) FH regions. Smaller regions merged FH cleanup stage. eight logical, default TRUE. TRUE, uses 8-neighborhood connectivity; otherwise 4-neighborhood. ms_dim integer, default 0. Number dimensions/bands use mean shift step. ms_ranger numeric, default 0.15. Spectral (range) bandwidth Mean-Shift clustering regions. Smaller values preserve spectral distinctions; larger values encourage region merging. ms_hs numeric, default 12. Spatial bandwidth (pixels) used Mean-Shift refinement. Controls spatial coherence merged regions. ms_max_iter integer, default 10. Maximum number Mean-Shift iterations per region. ms_eps numeric, default 1e-3. Convergence tolerance Mean-Shift mode estimation. mode_merge numeric, default 0.6. Threshold controlling merging nearby Mean-Shift modes. Higher values result aggressive merging similar regions. final_min_size integer, default 80. Minimum segment size (pixels) enforced Mean-Shift refinement. Remaining smaller segments merged spectrally closest neighbors. output_file Optional character string. provided, resulting segmentation raster written file via terra::writeRaster(). verbose progress messages? (default: TRUE)","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"SpatRaster.   single-layer raster cell contains integer segment ID.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"algorithm proceeds four main stages: Optional spatial smoothing per-band normalization. Initial -segmentation using FH graph-based method         (fast, noise-robust, edge-preserving). Region-level Mean-Shift clustering reduced spectral space         merge spectrally similar regions. Final region merging minimum-size enforcement. Compared pixel-level Mean-Shift, hybrid strategy substantially faster memory-efficient, producing spatially coherent, object-like segments suitable OBIA workflows. function optimized large images well suited object-based image analysis (OBIA) satellite UAV imagery. large rasters (tens hundreds millions pixels), consider tiling.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FH mean-shift hybrid geospatial image segmenter — fh_meanshift_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  img <- rast(\"multispectral_image.tif\")  seg <- fh_meanshift_segmenter(   img,   fh_k = 0.4,   fh_min_size = 30,   ms_ranger = 0.12,   ms_hs = 10,   final_min_size = 100 )  plot(seg) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter_tile.html","id":null,"dir":"Reference","previous_headings":"","what":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","title":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","text":"Convenience wrapper around [segmenter_tile_engine()] runs two-stage segmentation per tile: (1) Felzenszwalb-Huttenlocher (FH) superpixels (2) mean-shift clustering region features, followed seam-aware merging global relabeling.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter_tile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","text":"","code":"fh_meanshift_segmenter_tile(   x,   tile_size = 1536,   buffer = 96,   seam_thr = 0.8,   out_file = \"fh_meanshift_tiled_merged.tif\",   tile_dir = tempdir(),   cleanup_tiles = FALSE,   cleanup_seg_tiles = FALSE,   scale_bands = TRUE,   smooth = 3,   fh_k = 0.5,   fh_min_size = 20,   eight = TRUE,   ms_dim = 3,   ms_ranger = 0.15,   ms_hs = 12,   ms_max_iter = 10,   ms_eps = 0.001,   mode_merge = 0.6,   final_min_size = 80 )"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter_tile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","text":"x `SpatRaster` segment. tile_size Integer. Tile size pixels (rows/cols) excluding buffer. buffer Integer. Overlap (pixels) added around tile. seam_thr Numeric. Threshold merging seam-adjacent segments, applied Euclidean distance per-segment mean band vectors. out_file Character. Output file path final segmentation. tile_dir Character. Directory used intermediate tile products. cleanup_tiles Logical. `TRUE`, remove raw image tile files segmentation. cleanup_seg_tiles Logical. `TRUE`, remove segmented tile files final output produced. scale_bands Logical. `TRUE`, standardize bands processing. smooth Integer. Optional smoothing window size (pixels) applied input prior FH; `0` disables smoothing. fh_k Numeric. FH scale parameter (larger values generally yield larger base regions). fh_min_size Integer. Minimum FH region size pixels. eight Logical. `TRUE`, use 8-neighborhood connectivity; otherwise use 4-neighborhood. ms_dim Integer. Number dimensions used region feature vectors prior mean-shift. ms_ranger Numeric. Mean-shift range/bandwidth scaling parameter used region mean-shift stage. ms_hs Numeric. Mean-shift spatial/kernel bandwidth (implementation- specific; forwarded underlying mean-shift routine). ms_max_iter Integer. Maximum mean-shift iterations. ms_eps Numeric. Convergence tolerance mean-shift updates. mode_merge Numeric. Post-processing threshold controlling merging similar modes/clusters mean-shift. final_min_size Integer. Minimum final segment size (pixels) enforced region clustering mode merging.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter_tile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","text":"file-backed `SpatRaster` pointing `out_file`, containing   1-layer integer segmentation globally consecutive IDs.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_meanshift_segmenter_tile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tiled FH + region mean-shift segmentation with seam-aware merging — fh_meanshift_segmenter_tile","text":"wrapper provides tuned defaults high-resolution imagery intended robust, scalable OBIA-style segmenter large rasters. function sets `segment_fun = fh_meanshift_segmenter` forwards algorithm parameters `seg_args` [segmenter_tile_engine()].","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"Segments multi-band image using **Felzenszwalb-Huttenlocher** graph-based region merging algorithm (often used efficient OBIA-style \"superpixel\" generator). pixel node grid graph; edges connect neighboring pixels (4- 8-neighborhood) weights given spectral distance. Regions merged increasing edge-weight order subject adaptive internal-difference criterion controlled k, optional cleanup pass enforces minimum region size.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"","code":"fh_segmenter(   x,   k = 1,   min_size = 50,   eight = TRUE,   scale_bands = TRUE,   smooth = 0,   output_file = NULL,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"x SpatRaster one layers (bands). Bands numeric represent co-registered imagery (e.g., RGB, VNIR/SWIR). k Numeric scalar. Scale/threshold parameter controlling region merging. Larger k generally yields fewer, larger segments. min_size Integer scalar. Minimum allowed segment size (pixels). Segments smaller merged cleanup pass. eight Logical. TRUE, use 8-neighborhood connectivity; FALSE, use 4-neighborhood connectivity. scale_bands Logical. TRUE (recommended), band z-score scaled using mean standard deviation computed na.rm=TRUE. smooth Integer scalar. > 0, applies mean (box) filter size smooth x smooth band segmentation. Use small odd values (e.g., 3 5). Set 0 disable smoothing. output_file Optional character string. provided, resulting segmentation raster written file via terra::writeRaster(). verbose progress messages? (default: TRUE)","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"single-layer SpatRaster integer segment IDs   layer \"segment_id\". Invalid pixels NA.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"wrapper accepts SpatRaster returns single-layer label raster integer segment IDs. optionally applies mean (box) filter prior segmentation z-score scales band stabilize distance threshold across bands sensors. **Algorithm behavior** k controls tendency merge: larger values typically produce   larger segments. min_size enforces minimum mapping unit merging small regions   similar neighbor post-processing step. eight toggles 8-neighborhood (Queen) vs 4-neighborhood (Rook)   connectivity; 8-neighborhood usually yields \"diagonal-safe\" objects. scale_bands applies per-band z-score scaling using na.rm=TRUE. **NA handling** Pixels NA band treated invalid underlying C++ implementation returned NA output label raster. scene contains large NA areas, consider masking/cropping/filling prior segmentation avoid creating many invalid edge cases. **Performance notes** heavy lifting implemented Rcpp/C++ designed large rasters. large scenes, prefer tiling.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Felzenszwalb-Huttenlocher (FH) graph-based image segmentation — fh_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  r <- rast(\"image.tif\")  seg <- fh_segmenter(   r,   k = 0.5,   min_size = 20,   eight = TRUE,   scale_bands = TRUE,   smooth = 3 )  # Overlay boundaries on RGB rgb <- stretch(r[[1:3]]) bnd <- boundaries(seg, directions = 8) plotRGB(rgb, r=1, g=2, b=3, stretch=\"lin\") plot(bnd, add=TRUE, col=\"yellow\", lwd=0.8) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter_tile.html","id":null,"dir":"Reference","previous_headings":"","what":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","title":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","text":"Convenience wrapper around [segmenter_tile_engine()] runs package's FH segmenter disk-backed tiles performs seam-aware merging global relabeling produce single, consistent segmentation raster.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter_tile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","text":"","code":"fh_segmenter_tile(   x,   tile_size = 2048,   buffer = 64,   seam_thr = 0.7,   out_file = \"fh_tiled_merged.tif\",   tile_dir = tempdir(),   cleanup_tiles = FALSE,   cleanup_seg_tiles = FALSE,   k = 1,   min_size = 50,   eight = TRUE,   scale_bands = TRUE,   smooth = 0 )"},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter_tile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","text":"x `SpatRaster` segment. tile_size Integer. Tile size pixels (rows/cols) excluding buffer. buffer Integer. Overlap (pixels) added around tile. seam_thr Numeric. Threshold merging seam-adjacent segments, applied Euclidean distance per-segment mean band vectors. out_file Character. Output file path final segmentation. tile_dir Character. Directory used intermediate tile products. cleanup_tiles Logical. `TRUE`, remove raw image tile files segmentation. cleanup_seg_tiles Logical. `TRUE`, remove segmented tile files final output produced. k Numeric. FH scale parameter controlling degree merging (larger values generally yield larger segments). min_size Integer. Minimum segment size (pixels) enforced FH. eight Logical. `TRUE`, use 8-neighborhood connectivity; otherwise use 4-neighborhood. scale_bands Logical. `TRUE`, standardize bands segmentation. smooth Integer. Optional spatial smoothing window size (pixels); `0` disables smoothing.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter_tile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","text":"file-backed `SpatRaster` pointing `out_file`, containing   1-layer integer segmentation globally consecutive IDs.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/fh_segmenter_tile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tiled Felzenszwalb-Huttenlocher (FH) segmentation with seam-aware merging — fh_segmenter_tile","text":"function sets `segment_fun = fh_segmenter` forwards FH parameters `seg_args` [segmenter_tile_engine()].","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/make_tiles_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Create deterministic raster tiles on disk — make_tiles_disk","title":"Create deterministic raster tiles on disk — make_tiles_disk","text":"Splits large `SpatRaster` fixed-size tiles optional overlap (buffer) writes tile disk. Tiles generated deterministically row-column order accompanied metadata describing spatial layout buffered extents.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/make_tiles_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create deterministic raster tiles on disk — make_tiles_disk","text":"","code":"make_tiles_disk(   x,   tile_size = 2048,   buffer = 64,   prefix = \"tile\",   dir = tempdir(),   overwrite = TRUE,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/make_tiles_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create deterministic raster tiles on disk — make_tiles_disk","text":"x `SpatRaster` tiled. tile_size Integer. Size (pixels) tile along rows columns (excluding buffer). buffer Integer. Number pixels added overlap sides tile. prefix Character. Filename prefix generated tile files. dir Character. Output directory tiles written. overwrite Logical. Whether overwrite existing tile files. verbose Logical. `TRUE`, display progress information.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/make_tiles_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create deterministic raster tiles on disk — make_tiles_disk","text":"`data.frame` one row per tile following columns: tile_id Sequential tile identifier. file Path tile raster disk. r0_in, r1_in Row indices inner (unbuffered) tile. c0_in, c1_in Column indices inner (unbuffered) tile. r0_buf, r1_buf Row indices including buffer. c0_buf, c1_buf Column indices including buffer. buffer Buffer size (pixels).","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/make_tiles_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create deterministic raster tiles on disk — make_tiles_disk","text":"function designed scalable, disk-backed segmentation workflows large rasters must processed tile--tile preserving spatial consistency tile borders. Tiles cropped using spatial extents derived row/column indices, snapped raster grid avoid rounding artifacts. Output rasters written using tiled GeoTIFF LZW compression safe BigTIFF handling. Empty tiles (values) skipped. error raised tiles produced.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean-shift image segmentation — meanshift_segmenter","title":"Mean-shift image segmentation — meanshift_segmenter","text":"Performs image segmentation using **mean-shift filtering + clustering** approach multi-band rasters (RGB multispectral).","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean-shift image segmentation — meanshift_segmenter","text":"","code":"meanshift_segmenter(   x,   spatialr = 5L,   ranger = 1,   max_iter = 10L,   eps = 0.001,   merge_thr = NA_real_,   min_size = 30L,   eight = TRUE,   scale_bands = TRUE,   smooth = 0L,   return_filtered = FALSE,   output_file = NULL,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean-shift image segmentation — meanshift_segmenter","text":"x SpatRaster 1 bands. spatialr Integer \\(\\ge 1\\). Spatial radius (pixels) local neighborhood used mean-shift filtering. Larger values increase spatial smoothing runtime. ranger Positive numeric. Range bandwidth controlling strongly pixels weighted spectral similarity mean-shift filtering. Smaller values preserve edges aggressively; larger values smooth . max_iter Integer \\(\\ge 1\\). Maximum number mean-shift iterations per pixel. eps Positive numeric. Convergence tolerance mean-shift update. Iteration stops squared shift \\(\\le eps^2\\). merge_thr Optional numeric threshold used clustering filtered image. Neighboring pixels whose filtered spectral distance \\(\\le merge\\_thr\\) connected. NA (default), C++ routine uses 0.5 * ranger. min_size Integer \\(\\ge 1\\). Minimum segment size (pixels). Components smaller min_size merged similar neighboring component (based filtered spectral distance). eight Logical. TRUE, uses 8-neighborhood connectivity clustering also includes diagonal offsets mean-shift spatial neighborhood. FALSE, uses 4-neighborhood. scale_bands Logical. TRUE (default), standardizes band z-scores (x - mean) / sd using na.rm = TRUE. often recommended multispectral imagery bands different numeric ranges. smooth Integer \\(\\ge 0\\). Optional mean filter window size (pixels) applied raster prior mean-shift. 0 (default), pre-smoothing applied. > 0, smooth x smooth mean filter applied via terra::focal(). return_filtered Logical. FALSE (default), returns segmentation labels raster. TRUE, also returns filtered multi-band raster produced mean-shift. output_file Optional character string. provided, resulting segmentation raster written file via terra::writeRaster(). verbose Logical. TRUE, prints progress messages R wrapper. FALSE, runs quietly suppresses console output underlying C++ routine.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean-shift image segmentation — meanshift_segmenter","text":"return_filtered = FALSE, single-layer SpatRaster integer segment labels named \"segment_id\". return_filtered = TRUE, list : segments Single-layer labels SpatRaster. filtered Multi-layer SpatRaster mean-shift   filtered bands (number layers x).","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mean-shift image segmentation — meanshift_segmenter","text":"method first applies mean-shift *range filtering* (edge-preserving smoothing) local spatial neighborhood, groups pixels connected components based similarity filtered values. Small components can merged similar neighboring component. high-level R wrapper around C++ implementation optimized raster grids multi-band imagery. **Algorithm outline (C++ implementation):** Validity mask: pixel marked invalid band NA finite. Invalid pixels receive label 0 C++ converted NA output raster. Mean-shift filtering: valid pixel, algorithm iteratively updates spectral vector \\(y\\) using weighted mean local neighborhood within spatialr. weight product : Gaussian spatial kernel (sigma \\(\\approx spatialr/2\\)), Gaussian range kernel based spectral distance   bandwidth ranger. Iteration stops max_iter steps update magnitude eps. Clustering: filtered image clustered building connected components grid. Neighboring pixels linked squared distance filtered spectral vectors merge_thr^2. Connectivity follows eight. Minimum size enforcement: Components smaller min_size merged similar neighboring component using local neighbor search. Relabeling: Components relabeled consecutive integers 1..K. Invalid pixels remain NA R output. Internally, pixel values passed C++ band-major layout (pixels band 1, pixels band 2, ...). wrapper handles conversion terra values.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/meanshift_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean-shift image segmentation — meanshift_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  r <- terra::rast(sample_raster_path())  # MeanShift segmentation (labels only) seg <- meanshift_segmenter(   r,   spatialr = 5,   ranger = 1.0,   min_size = 50,   eight = TRUE,   scale_bands = TRUE,   smooth = 0,   verbose = TRUE ) plot(seg)  # Also return the filtered image res <- meanshift_segmenter(r, return_filtered = TRUE, verbose = FALSE) plot(res$segments) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge adjacent segments by spectral similarity — merge_by_adjacency","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"Given set adjacent segment ID pairs per-segment mean feature vectors, compute mapping merges (clusters) segments whose mean vectors sufficiently similar. Similarity evaluated segments adjacent (share edge/corner), merges propagated transitively via union-find (disjoint-set) structure.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"","code":"merge_by_adjacency(adj_pairs, means, thr)"},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"adj_pairs Integer matrix two columns. row undirected adjacency segment IDs (e.g., output `extract_seam_pairs()`). Pairs may contain duplicates; need sorted. means Numeric matrix per-segment mean features (e.g., band means). Row names must segment IDs character strings (e.g., `\"123\"`), columns feature dimensions (bands derived features). thr Numeric scalar. Merge threshold applied Euclidean distance mean feature vectors. Adjacent segments distance `< thr` merged component.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"integer vector mapping segment IDs representative IDs.   vector named original segment IDs (character) values   representative IDs (integer). IDs present `adj_pairs`   included. `adj_pairs` empty, returns empty named integer   vector.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"function typically used extracting seam boundary adjacencies (e.g., tiled segmentations) reconcile segment IDs across tiles reduce seam artifacts merging regions near-identical spectral means. **Algorithm.** adjacency `(, b)`, function extracts feature vectors `means[, ]` `means[b, ]` computes Euclidean distance `d = sqrt(sum((da - db)^2))`. `d < thr` vectors contain `NA`, segments unioned disjoint-set (union-find) structure. pairs processed, segment assigned representative connected component (path compression accelerate repeated finds). **Transitivity.** union-find forms connected components, merges transitive: `` merges `b` `b` merges `c`, ``, `b`, `c` share representative even `(, c)` never explicit adjacency. **Representatives.** Representatives chosen union order (root union-find structure), necessarily smallest ID. require canonical representatives (e.g., minimum ID per component), post-process mapping accordingly. **Robustness.** Pairs whose feature vectors contain `NA` skipped. IDs appearing `adj_pairs` considered; `means` contains additional segments present `adj_pairs`, appear output map.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/merge_by_adjacency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge adjacent segments by spectral similarity — merge_by_adjacency","text":"","code":"if (FALSE) { # \\dontrun{  # Example adjacency pairs (undirected) adj <- matrix(c(1,2, 2,3, 10,11), ncol = 2, byrow = TRUE) means <- rbind(   \"1\"  = c(0.10, 0.20),   \"2\"  = c(0.11, 0.19),   \"3\"  = c(0.12, 0.18),   \"10\" = c(0.80, 0.75),   \"11\" = c(0.81, 0.74) ) merge_by_adjacency(adj, means, thr = 0.05) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/relabel_segments_global.html","id":null,"dir":"Reference","previous_headings":"","what":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","title":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","text":"Reassigns non-`NA` segment IDs segmentation raster consecutive integer sequence `1..K` writes result disk using streaming /O. useful merging/reconciliation steps produce compact, stable IDs downstream feature extraction polygonization.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/relabel_segments_global.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","text":"","code":"relabel_segments_global(seg, out_file, block_nrows = 1024L)"},{"path":"http://joaogoncalves.cc/rsegm/reference/relabel_segments_global.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","text":"seg `SpatRaster` containing integer segment labels. out_file Character. Output file path (GeoTIFF recommended). block_nrows Integer. Number rows per streaming block reading writing.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/relabel_segments_global.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","text":"file-backed `SpatRaster` pointing `out_file`.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/relabel_segments_global.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relabel segments to a global consecutive ID scheme (streaming-safe) — relabel_segments_global","text":"function first ensures `seg` file-backed (written temporary GeoTIFF) support robust streaming reads. computes set unique segment IDs using `terra::freq(..., bylayer = FALSE)` maps sorted order `1..K`. `NA` values ignored preserved. relabeling applied block-wise using `readValues()` / `writeValues()`, avoiding full -memory materialization. Output written `INT4S` package's default GDAL creation options. **Determinism.** unique IDs sorted mapping, resulting labels deterministic given raster (subject identical numeric values `seg`).","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Example RGB GeoTIFF (UTM 35N) — sample_raster","title":"Example RGB GeoTIFF (UTM 35N) — sample_raster","text":"small 3-band (RGB) GeoTIFF used examples, vignettes, tests.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example RGB GeoTIFF (UTM 35N) — sample_raster","text":"GeoTIFF file `inst/extdata/`.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example RGB GeoTIFF (UTM 35N) — sample_raster","text":"file shipped package : `system.file(\"extdata\", \"sample_raster.tif\", package = \"rsegm\")`. Read : `terra::rast(system.file(\"extdata\",\"sample_raster.tif\", package=\"rsegm\", mustWork=TRUE))`.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Path to an example raster — sample_raster_path","title":"Path to an example raster — sample_raster_path","text":"Path example raster","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Path to an example raster — sample_raster_path","text":"","code":"sample_raster_path()"},{"path":"http://joaogoncalves.cc/rsegm/reference/sample_raster_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Path to an example raster — sample_raster_path","text":"file path example GeoTIFF shipped package.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":null,"dir":"Reference","previous_headings":"","what":"SEEDS superpixel segmentation — seeds_segmenter","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"Generates **superpixels** using SEEDS-like hierarchical approach based fast **histogram block moves**. method starts regular grid initial labels iteratively refines boundaries proposing block-wise label changes improve histogram-based objective.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"","code":"seeds_segmenter(   x,   step = 10L,   nbins = 20L,   block_sizes = c(8L, 4L, 2L, 1L),   iters_per_level = 5L,   boundary_samples = 8L,   alpha = 1,   smooth = 0L,   output_file = NULL,   verbose = FALSE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"x SpatRaster \\(\\ge 1\\) layer (band). step Integer \\(\\ge 1\\). Approximate initial superpixel spacing pixels. Larger values produce fewer (larger) superpixels. Internally sets size initial grid cells used initialize labels. nbins Integer \\(\\ge 2\\). Number histogram bins per band. Pixel values quantized per band based band's min/max (computed ignoring NA/NaN). block_sizes Integer vector hierarchical block sizes (coarse--fine), e.g. c(8,4,2,1). level, candidate moves proposed aligned bs x bs blocks, refining boundaries progressively. iters_per_level Integer \\(\\ge 1\\). Number refinement iterations per hierarchy level block_sizes. boundary_samples Integer \\(\\ge 1\\). Sampling effort knob controlling many boundary-proposal samples evaluated per iteration. Internally C++ routine scales number samples roughly number labels (K) caps safety. alpha Non-negative numeric. Additive smoothing constant histogram probabilities (Laplace-like smoothing). Higher values reduce sensitivity small counts can stabilize results. smooth Integer \\(\\ge 0\\). Optional mean filter window size (pixels) applied raster prior mean-shift. 0 (default), pre-smoothing applied. > 0, smooth x smooth mean filter applied via terra::focal(). output_file Optional character string. provided, resulting segmentation raster written file via terra::writeRaster(). verbose Logical. TRUE, prints progress messages R wrapper allows C++ routine check user interrupts refinement loop. FALSE, runs quietly.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"single-layer SpatRaster   integer superpixel IDs layer named \"seeds\".","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"wrapper intended **tile-friendly** (fast, local updates) can used inside tiling strategies large rasters. **Implementation notes (C++):** Quantization: band quantized nbins using   per-band min/max computed finite values. NaN values quantized   -1 ignored histogram updates. Initialization: labels initialized regular grid   cell size step (pixels). Labels start 0..K-1 C++,   returned R 1..K. Moves: hierarchy level, algorithm samples boundary   pixels, finds 4-neighbour label competitor, evaluates whether moving   aligned bs x bs block region region B increases histogram   score. beneficial, pixels label inside block reassigned. Determinism: sampler uses deterministic RNG C++,   yielding reproducible results given inputs parameters. Missing values: unlike segmenters rsegm, SEEDS implementation explicitly mask NA pixels. Pixels NA/NaN contribute histograms, still receive label. Consider pre-filling masking NA regions excluded.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/seeds_segmenter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SEEDS superpixel segmentation — seeds_segmenter","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) r <- terra::rast(sample_raster_path())  spx <- seeds_segmenter(   r,   step = 12,   nbins = 20,   block_sizes = c(8, 4, 2, 1),   iters_per_level = 5,   boundary_samples = 8,   alpha = 1.0,   verbose = TRUE ) plot(spx) } # }"},{"path":"http://joaogoncalves.cc/rsegm/reference/segmenter_tile_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","title":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","text":"Runs complete tiled segmentation workflow large `SpatRaster`: (1) tile disk overlap, (2) segment tile disk globally unique IDs, (3) detect seam adjacencies, (4) compute per-segment means tiles, (5) merge adjacent seam segments similarity, (6) apply merges streamingly, (7) relabel segments globally consecutive IDs.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segmenter_tile_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","text":"","code":"segmenter_tile_engine(   x,   segment_fun,   seg_args,   tile_size = 2048,   buffer = 64,   seam_thr = 0.8,   out_file = \"final_seg.tif\",   tile_dir = tempdir(),   cleanup_tiles = FALSE,   cleanup_seg_tiles = FALSE,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/segmenter_tile_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","text":"x `SpatRaster` segment (single- multi-band). segment_fun function implementing segmentation single tile. Must accept `SpatRaster` first argument return 1-layer integer segmentation raster. seg_args named list additional arguments passed `segment_fun`. tile_size Integer. Tile size pixels (rows/cols) excluding buffer. buffer Integer. Overlap (pixels) added around tile. seam_thr Numeric scalar. Threshold merging seam-adjacent segments. Applied Euclidean distance per-segment mean feature vectors. out_file Character. Output file path final segmentation. tile_dir Character. Directory used intermediate tile products. cleanup_tiles Logical. `TRUE`, remove raw image tiles segmentation. cleanup_seg_tiles Logical. `TRUE`, remove segmented tile files final output produced. verbose Logical. `TRUE`, print progress messages.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segmenter_tile_engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","text":"file-backed `SpatRaster` pointing `out_file`, containing   1-layer integer segmentation globally consecutive IDs.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segmenter_tile_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tiled segmentation engine with seam-aware merging and global relabeling — segmenter_tile_engine","text":"function intended robust, memory-safe orchestration layer classical OBIA workflows full-scene segmentation infeasible RAM. See vignette(\"tiled-segmentation-workflow\") end--end explanation tiling seam-merge framework. **Seam-aware merging.** Seam adjacencies extracted overlap zone (buffer) tile identify segment labels touch across tile borders. Segment means computed original image values using tile-wise streaming (VRT reads). Adjacent segments merged mean vectors within `seam_thr`, using transitive closure (union-find). **Fast path merges needed.** seam adjacencies found (candidate adjacencies invalid due missing means), function mosaics segmented tiles directly `out_file` without merging. **Streaming-safe output.** applying merge map, segmented tile mosaic materialized real file-backed raster ensure stable block reads/writes. Merging final relabeling performed using streaming reads/writes support large rasters.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_means_from_tiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","title":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","text":"Computes mean spectral values set segment IDs iterating segmentation tiles stored disk streaming values original image raster. function avoids virtual raster (VRT) reads designed memory-safe processing large images.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_means_from_tiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","text":"","code":"segment_means_from_tiles(img, seg_tile_files, ids, block_nrows = 512)"},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_means_from_tiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","text":"img `SpatRaster` containing original multi-band image data. seg_tile_files Character vector file paths segmentation tiles (e.g., produced [make_tiles_disk()]). ids Integer vector segment IDs means computed. block_nrows Integer. Number raster rows process per read block streaming values disk.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_means_from_tiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","text":"numeric matrix `length(ids)` rows `nlyr(img)` columns.   Rows correspond segment IDs (order `ids`), columns   correspond image bands. Segments contributing pixels return   `NA` values.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_means_from_tiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute per-segment band means from tiled segmentations — segment_means_from_tiles","text":"segmentation tile, corresponding spatial subset `img` cropped read row blocks. grid geometry differs image tile, image subset resampled tile grid streaming. Accumulation performed sums pixel counts per segment, followed normalization means. Segment labels `NA` values ignored. function typically used tiled segmentation ID reconciliation compute region statistics without loading full rasters memory.","code":""},{"path":[]},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_tiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Segment each raster tile to disk with globally unique IDs — segment_tiles","title":"Segment each raster tile to disk with globally unique IDs — segment_tiles","text":"Applies user-provided segmentation function tile described tiling metadata table writes resulting 1-layer integer segmentation disk. Segment IDs made globally unique across tiles applying running offset positive labels.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_tiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segment each raster tile to disk with globally unique IDs — segment_tiles","text":"","code":"segment_tiles(   tile_meta,   segment_fun,   seg_args,   out_dir,   out_prefix = \"seg\",   overwrite = TRUE,   cleanup_tiles = FALSE,   force_positive = TRUE,   verbose = TRUE )"},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_tiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Segment each raster tile to disk with globally unique IDs — segment_tiles","text":"tile_meta `data.frame` describing input tiles disk. Must contain `file` column paths tile rasters (e.g., output [make_tiles_disk()]). segment_fun function implementing segmentation single tile. must accept `SpatRaster` first argument return 1-layer `SpatRaster` integer segment labels (something coercible ). seg_args named list additional arguments passed `segment_fun` via `.call()`. out_dir Character. Directory segmented tile rasters written. out_prefix Character. Filename prefix segmented tile outputs. overwrite Logical. Whether overwrite existing output files. cleanup_tiles Logical. `TRUE`, delete input tile rasters successful segmentation. force_positive Logical. `TRUE`, assumes segmenter may emit non-positive labels enforces semantics labels `> 0` offset ensure global uniqueness (leaving `0` `NA` unchanged). verbose Logical. `TRUE`, display progress information.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_tiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Segment each raster tile to disk with globally unique IDs — segment_tiles","text":"character vector file paths segmented tile rasters (one per   row `tile_meta`), processing order.","code":""},{"path":"http://joaogoncalves.cc/rsegm/reference/segment_tiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Segment each raster tile to disk with globally unique IDs — segment_tiles","text":"function designed used step tiled segmentation engine, can also used standalone users want explicit control tiling/segmentation subsequent merging. **Failure handling.** segmentation fails tile (error values), -`NA` segmentation tile written disk downstream steps can proceed deterministically. **Global uniqueness.** tile segmented, maximum positive ID computed used update global offset. Positive labels shifted current offset prevent ID collisions across tiles. output written `INT4S` (32-bit signed integer); error raised offset overflow range.","code":""},{"path":[]}]
